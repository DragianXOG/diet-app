from sqlalchemy import text
from typing import List, Optional, Dict
from datetime import datetime
from pydantic import BaseModel, conint, confloat
from fastapi import APIRouter, Depends, HTTPException, Query
from sqlmodel import Session, select

from ..core.db import get_session
from ..core.security import get_current_user
from ..models import User, Meal, MealItem, GroceryItem, Intake
from typing import Any, Literal
from datetime import date as _date, time as _time, timedelta as _td, datetime as _dt
import os, json

router = APIRouter()

# ---------- Meals ----------
class MealItemIn(BaseModel):
    name: str
    calories: Optional[conint(ge=0)] = None
    quantity: Optional[confloat(ge=0)] = None
    unit: Optional[str] = None

class MealCreate(BaseModel):
    name: str
    eaten_at: Optional[datetime] = None
    items: List[MealItemIn] = []

@router.post("/meals", status_code=201)
def create_meal(payload: MealCreate, user: User = Depends(get_current_user), session: Session = Depends(get_session)):
    # Set RLS context for this transaction
    session.exec(text("SET app.user_id = :uid").bindparams(uid=user.id))
    try:
        meal = Meal(
            user_id=user.id,
            name=payload.name,
            eaten_at=payload.eaten_at or datetime.utcnow(),
            total_calories=(sum(i.calories or 0 for i in payload.items) if payload.items else None),
        )
        session.add(meal)
        session.flush()  # get meal.id before adding items

        for it in payload.items:
            mi = MealItem(meal_id=meal.id, name=it.name, calories=it.calories, quantity=it.quantity, unit=it.unit)
            session.add(mi)

        session.commit()
        return {"id": meal.id, "name": meal.name, "eaten_at": meal.eaten_at.isoformat(), "total_calories": meal.total_calories, "items": len(payload.items)}
    finally:
        session.exec(text("RESET app.user_id"))
@router.get("/meals")
def list_meals(
    user: User = Depends(get_current_user),
    session: Session = Depends(get_session),
    limit: int = Query(50, ge=1, le=100),
):
    # Set RLS context for this transaction so SELECT can see only this user's rows
    session.exec(text("SET app.user_id = :uid").bindparams(uid=user.id))
    try:
        meals = session.exec(
            select(Meal).where(Meal.user_id == user.id).order_by(Meal.eaten_at.desc()).limit(limit)
        ).all()

        by_meal = {}
        if meals:
            meal_ids = [m.id for m in meals]
            items = session.exec(select(MealItem).where(MealItem.meal_id.in_(meal_ids))).all()
            for it in items:
                by_meal.setdefault(it.meal_id, []).append(it)

        out = []
        for m in meals:
            out.append({
                "id": m.id,
                "name": m.name,
                "eaten_at": m.eaten_at.isoformat(),
                "total_calories": m.total_calories,
                "items": [{"name": it.name, "calories": it.calories, "qty": it.quantity, "unit": it.unit} for it in by_meal.get(m.id, [])]
            })
        return out
    finally:
        session.exec(text("RESET app.user_id"))

# ---------- Groceries ----------# ---------- Groceries ----------
class GroceryIn(BaseModel):
    name: str
    quantity: Optional[confloat(ge=0)] = None
    unit: Optional[str] = None

class GroceryUpdate(BaseModel):
    purchased: bool

@router.post("/groceries", status_code=201)
def add_grocery(payload: GroceryIn, user: User = Depends(get_current_user), session: Session = Depends(get_session)):
    # Set RLS context
    session.exec(text("SET app.user_id = :uid").bindparams(uid=user.id))
    try:
        g = GroceryItem(user_id=user.id, name=payload.name, quantity=payload.quantity, unit=payload.unit, purchased=False)
        session.add(g)
        session.commit()
        return {"id": g.id, "name": g.name, "quantity": g.quantity, "unit": g.unit, "purchased": g.purchased}
    finally:
        session.exec(text("RESET app.user_id"))

@router.get("/groceries")
def list_groceries(
    user: User = Depends(get_current_user),
    session: Session = Depends(get_session),
    only_open: bool = Query(True),
):
    # Set RLS context
    session.exec(text("SET app.user_id = :uid").bindparams(uid=user.id))
    try:
        q = select(GroceryItem).where(GroceryItem.user_id == user.id)
        if only_open:
            q = q.where(GroceryItem.purchased == False)  # noqa: E712
        rows = session.exec(q.order_by(GroceryItem.created_at.desc())).all()
        return [{"id": r.id, "name": r.name, "quantity": r.quantity, "unit": r.unit, "purchased": r.purchased, "created_at": r.created_at.isoformat()} for r in rows]
    finally:
        session.exec(text("RESET app.user_id"))

@router.patch("/groceries/{item_id}")
def update_grocery(item_id: int, payload: GroceryUpdate, user: User = Depends(get_current_user), session: Session = Depends(get_session)):
    # Set RLS context
    session.exec(text("SET app.user_id = :uid").bindparams(uid=user.id))
    try:
        g = session.get(GroceryItem, item_id)
        if not g or g.user_id != user.id:
            raise HTTPException(status_code=404, detail="Item not found")
        g.purchased = payload.purchased
        session.add(g)
        session.commit()
        return {"id": g.id, "name": g.name, "purchased": g.purchased}
    finally:
        session.exec(text("RESET app.user_id"))



@router.post("/groceries/sync_from_meals")
def sync_groceries_from_meals(
    start: Optional[str] = Query(None, description="YYYY-MM-DD"),
    end: Optional[str] = Query(None, description="YYYY-MM-DD"),
    persist: bool = Query(True),
    clear_existing: bool = Query(False),
    seed_if_empty: bool = Query(True, description="If no meals exist in window, use a default 7-day, 2-meals/day plan and (when persist) seed meals."),
    user: User = Depends(get_current_user),
    session: Session = Depends(get_session),
):
    """
    Aggregate grocery items from meals in [start, end] (inclusive).
    - Uses real MealItem rows when present.
    - If a meal has no items, falls back to default ingredients by dish name.
    - If there are no meals at all in the window and seed_if_empty=True, it uses
      a default 7-day, 2-meals/day schedule and (if persist) seeds Meal rows.
    When persist=true, writes to grocery_items (respecting RLS).
    """
    from datetime import datetime as _dt, timedelta as _td, date as _date, time as _time

    # Window [start_dt, end_excl)
    today = _dt.utcnow().date()
    sdate = _date.fromisoformat(start) if start else today
    edate = _date.fromisoformat(end) if end else (sdate + _td(days=6))
    start_dt = _dt.combine(sdate, _time(0,0))
    end_excl = _dt.combine(edate + _td(days=1), _time(0,0))

    # Default ingredient fallback by dish name
    fallback = {
        "Chicken Caesar Bowl": [("Chicken breast", 1.5, "lb"), ("Romaine", 2, "heads"), ("Parmesan", 1, "cup"), ("Caesar dressing", 1, "bottle")],
        "Salmon & Asparagus": [("Salmon fillets", 4, "pcs"), ("Asparagus", 2, "bunch"), ("Lemon", 2, "pcs")],
        "Turkey Lettuce Wraps": [("Ground turkey", 1, "lb"), ("Lettuce", 2, "heads"), ("Bell peppers", 2, "pcs")],
        "Lean Turkey Chili": [("Ground turkey", 2, "lb"), ("Diced tomatoes", 2, "cans"), ("Kidney beans", 2, "cans"), ("Chili seasoning", 1, "packet")],
        "Tuna Nicoise": [("Canned tuna", 4, "cans"), ("Green beans", 1, "lb"), ("Eggs", 6, "pcs"), ("Olives", 1, "jar")],
        "Baked Cod & Broccoli": [("Cod fillets", 4, "pcs"), ("Broccoli", 2, "heads"), ("Olive oil", 1, "bottle")],
        "Greek Chicken Bowl": [("Chicken breast", 1.5, "lb"), ("Cucumber", 2, "pcs"), ("Tomatoes", 4, "pcs"), ("Feta", 1, "block")],
        "Turkey Meatballs & Veg": [("Ground turkey", 1.5, "lb"), ("Marinara", 1, "jar"), ("Zucchini", 3, "pcs"), ("Parmesan", 1, "cup")],
        "Beef & Veg Stir-Fry": [("Beef strips", 1.5, "lb"), ("Broccoli", 1, "head"), ("Bell peppers", 2, "pcs"), ("Soy sauce", 1, "bottle")],
        "Chicken Fajita Bowl": [("Chicken breast", 1.5, "lb"), ("Bell peppers", 3, "pcs"), ("Onions", 2, "pcs"), ("Fajita seasoning", 1, "packet")],
        "Shrimp & Zoodles": [("Shrimp", 2, "lb"), ("Zucchini", 4, "pcs"), ("Garlic", 1, "bulb")],
        "Steak & Big Salad": [("Steak", 2, "lb"), ("Mixed greens", 2, "bags"), ("Cherry tomatoes", 2, "pints")],
        "Egg Roll in a Bowl": [("Ground pork", 1, "lb"), ("Cabbage", 1, "head"), ("Soy sauce", 1, "bottle")],
        "Garlic Chicken & Veg": [("Chicken thighs", 1.5, "lb"), ("Green beans", 1, "lb"), ("Garlic", 1, "bulb")],
    }
    default_meals1 = ["Chicken Caesar Bowl","Turkey Lettuce Wraps","Tuna Nicoise","Greek Chicken Bowl","Beef & Veg Stir-Fry","Shrimp & Zoodles","Egg Roll in a Bowl"]
    default_meals2 = ["Salmon & Asparagus","Lean Turkey Chili","Baked Cod & Broccoli","Turkey Meatballs & Veg","Chicken Fajita Bowl","Steak & Big Salad","Garlic Chicken & Veg"]

    # Set RLS context
    session.exec(text("SET app.user_id = :uid").bindparams(uid=user.id))
    try:
        meals = session.exec(
            select(Meal)
            .where(Meal.user_id == user.id)
            .where(Meal.eaten_at >= start_dt, Meal.eaten_at < end_excl)
            .order_by(Meal.eaten_at.asc())
        ).all()

        agg = {}
        def add(name, qty, unit):
            key = (name.strip(), (unit or "").strip())
            agg[key] = agg.get(key, 0.0) + float(qty if qty is not None else 1.0)

        if not meals and seed_if_empty:
            days = (edate - sdate).days + 1
            schedule = []
            for i in range(days):
                day = sdate + _td(days=i)
                d1 = default_meals1[i % len(default_meals1)]
                d2 = default_meals2[i % len(default_meals2)]
                schedule.append((day, d1, d2))

            # Seed meal rows (for UI visibility) and aggregate fallback groceries
            if persist:
                for day, d1, d2 in schedule:
                    session.add(Meal(user_id=user.id, name=f"Meal 1 - {d1}", eaten_at=_dt.combine(day, _time(12,30))))
                    session.add(Meal(user_id=user.id, name=f"Meal 2 - {d2}", eaten_at=_dt.combine(day, _time(18,30))))
                session.flush()

            for _, d1, d2 in schedule:
                for dish in (d1, d2):
                    for (n,q,u) in fallback.get(dish, []):
                        add(n,q,u)

        else:
            # Use real items when present; otherwise fallback by dish name
            meal_ids = [m.id for m in meals] if meals else []
            items_by_meal = {}
            if meal_ids:
                mis = session.exec(select(MealItem).where(MealItem.meal_id.in_(meal_ids))).all()
                for it in mis:
                    items_by_meal.setdefault(it.meal_id, []).append(it)

            for m in meals:
                real_items = items_by_meal.get(m.id, [])
                if real_items:
                    for it in real_items:
                        add(it.name, it.quantity if it.quantity is not None else 1.0, it.unit)
                else:
                    dish = m.name.split(" - ", 1)[-1]
                    for (n,q,u) in fallback.get(dish, []):
                        add(n,q,u)

        out = [{"name": k[0], "quantity": round(v, 2), "unit": (k[1] or None)} for k, v in sorted(agg.items(), key=lambda x: x[0][0].lower())]

        if persist and out:
            if clear_existing:
                session.exec(text("DELETE FROM grocery_items WHERE user_id = :uid AND (purchased IS NULL OR purchased = false)").bindparams(uid=user.id))
            for row in out:
                session.add(GroceryItem(user_id=user.id, name=row["name"], quantity=row["quantity"], unit=row["unit"], purchased=False))
            session.commit()

        return {"window": {"start": sdate.isoformat(), "end": edate.isoformat()}, "count": len(out), "items": out}
    finally:
        session.exec(text("RESET app.user_id"))
# ---------- Intake (DB-backed with RLS) ----------
@router.post("/groceries/sync_from_meals")
def sync_groceries_from_meals(
    start: Optional[str] = Query(None, description="YYYY-MM-DD"),
    end: Optional[str] = Query(None, description="YYYY-MM-DD"),
    persist: bool = Query(True),
    clear_existing: bool = Query(False),
    user: User = Depends(get_current_user),
    session: Session = Depends(get_session),
):
    """
    Aggregate grocery items from meals in [start, end] (inclusive).
    Uses real MealItem rows when present; if a meal has no items, falls back to a small
    default ingredient list based on the meal name to make the demo useful.
    When persist=true, writes to grocery_items (respecting RLS).
    """
    from datetime import datetime as _dt, timedelta as _td, date as _date

    # Helper: parse dates and build datetime window [start_dt, end_excl)
    today = _dt.utcnow().date()
    sdate = _date.fromisoformat(start) if start else today
    edate = _date.fromisoformat(end) if end else (sdate + _td(days=6))
    start_dt = _dt.combine(sdate, _dt.min.time())
    end_excl = _dt.combine(edate + _td(days=1), _dt.min.time())

    # Default ingredient fallback by dish name (match on the substring after " - ")
    fallback = {
        "Chicken Caesar Bowl": [("Chicken breast", 1.5, "lb"), ("Romaine", 2, "heads"), ("Parmesan", 1, "cup"), ("Caesar dressing", 1, "bottle")],
        "Salmon & Asparagus": [("Salmon fillets", 4, "pcs"), ("Asparagus", 2, "bunch"), ("Lemon", 2, "pcs")],
        "Turkey Lettuce Wraps": [("Ground turkey", 1, "lb"), ("Lettuce", 2, "heads"), ("Bell peppers", 2, "pcs")],
        "Lean Turkey Chili": [("Ground turkey", 2, "lb"), ("Diced tomatoes", 2, "cans"), ("Kidney beans", 2, "cans"), ("Chili seasoning", 1, "packet")],
        "Tuna Nicoise": [("Canned tuna", 4, "cans"), ("Green beans", 1, "lb"), ("Eggs", 6, "pcs"), ("Olives", 1, "jar")],
        "Baked Cod & Broccoli": [("Cod fillets", 4, "pcs"), ("Broccoli", 2, "heads"), ("Olive oil", 1, "bottle")],
        "Greek Chicken Bowl": [("Chicken breast", 1.5, "lb"), ("Cucumber", 2, "pcs"), ("Tomatoes", 4, "pcs"), ("Feta", 1, "block")],
        "Turkey Meatballs & Veg": [("Ground turkey", 1.5, "lb"), ("Marinara", 1, "jar"), ("Zucchini", 3, "pcs"), ("Parmesan", 1, "cup")],
        "Beef & Veg Stir-Fry": [("Beef strips", 1.5, "lb"), ("Broccoli", 1, "head"), ("Bell peppers", 2, "pcs"), ("Soy sauce", 1, "bottle")],
        "Chicken Fajita Bowl": [("Chicken breast", 1.5, "lb"), ("Bell peppers", 3, "pcs"), ("Onions", 2, "pcs"), ("Fajita seasoning", 1, "packet")],
        "Shrimp & Zoodles": [("Shrimp", 2, "lb"), ("Zucchini", 4, "pcs"), ("Garlic", 1, "bulb")],
        "Steak & Big Salad": [("Steak", 2, "lb"), ("Mixed greens", 2, "bags"), ("Cherry tomatoes", 2, "pints")],
        "Egg Roll in a Bowl": [("Ground pork", 1, "lb"), ("Cabbage", 1, "head"), ("Soy sauce", 1, "bottle")],
        "Garlic Chicken & Veg": [("Chicken thighs", 1.5, "lb"), ("Green beans", 1, "lb"), ("Garlic", 1, "bulb")],
    }

    # Set RLS context
    session.exec(text("SET app.user_id = :uid").bindparams(uid=user.id))
    try:
        # Pull meals for window
        meals = session.exec(
            select(Meal)
            .where(Meal.user_id == user.id)
            .where(Meal.eaten_at >= start_dt, Meal.eaten_at < end_excl)
            .order_by(Meal.eaten_at.asc())
        ).all()

        meal_ids = [m.id for m in meals] if meals else []
        items_by_meal = {}
        if meal_ids:
            mis = session.exec(select(MealItem).where(MealItem.meal_id.in_(meal_ids))).all()
            for it in mis:
                items_by_meal.setdefault(it.meal_id, []).append(it)

        # Aggregate { (name, unit) -> qty }
        agg = {}
        def add(name, qty, unit):
            key = (name.strip(), (unit or "").strip())
            agg[key] = agg.get(key, 0.0) + float(qty if qty is not None else 1.0)

        for m in meals:
            real_items = items_by_meal.get(m.id, [])
            if real_items:
                for it in real_items:
                    add(it.name, it.quantity if it.quantity is not None else 1.0, it.unit)
            else:
                # derive dish name
                dish = m.name.split(" - ", 1)[-1]
                if dish in fallback:
                    for (n, q, u) in fallback[dish]:
                        add(n, q, u)

        out = [{"name": k[0], "quantity": round(v, 2), "unit": (k[1] or None)} for k, v in sorted(agg.items(), key=lambda x: x[0][0].lower())]

        if persist and out:
            if clear_existing:
                # Clear current unpurchased rows for this user to avoid duplicates
                session.exec(text("DELETE FROM grocery_items WHERE user_id = :uid AND (purchased IS NULL OR purchased = false)").bindparams(uid=user.id))
            for row in out:
                gi = GroceryItem(user_id=user.id, name=row["name"], quantity=row["quantity"], unit=row["unit"], purchased=False)
                session.add(gi)
            session.commit()

        return {"window": {"start": sdate.isoformat(), "end": edate.isoformat()}, "count": len(out), "items": out}
    finally:
        session.exec(text("RESET app.user_id"))

# ---------- Intake (DB-backed with RLS) ----------
class IntakeIn(BaseModel):
    food_notes: Optional[str] = None
    workout_notes: Optional[str] = None
    name: Optional[str] = None
    age: Optional[int] = None
    sex: Optional[str] = None
    height_in: Optional[int] = None
    weight_lb: Optional[int] = None
    diabetic: Optional[bool] = None
    conditions: Optional[str] = None
    meds: Optional[str] = None
    goals: Optional[str] = None
    zip: Optional[str] = None
    gym: Optional[str] = None

@router.get("/intake")
def get_intake(
    user: User = Depends(get_current_user),
    session: Session = Depends(get_session),
):
    # Set RLS context for this transaction
    session.exec(text("SET app.user_id = :uid").bindparams(uid=user.id))
    row = session.exec(
        select(Intake).where(Intake.user_id == user.id).order_by(Intake.id.desc()).limit(1)
    ).first()
    if not row:
        return None
    session.exec(text("RESET app.user_id"));
    session.exec(text("RESET app.user_id"));
    return {
        "id": row.id,
        "user_id": row.user_id,
        "name": row.name,
        "age": row.age,
        "sex": row.sex,
        "height_in": row.height_in,
        "weight_lb": row.weight_lb,
        "diabetic": row.diabetic,
        "conditions": row.conditions,
        "meds": row.meds,
        "goals": row.goals,
        "zip": row.zip,
        "gym": row.gym,
        "food_notes": getattr(row, "food_notes", None),
        "workout_notes": getattr(row, "workout_notes", None),
        "created_at": row.created_at.isoformat() if row.created_at else None,
        "updated_at": row.updated_at.isoformat() if row.updated_at else None,
    }

@router.post("/intake", status_code=201)
def upsert_intake(
    payload: IntakeIn,
    user: User = Depends(get_current_user),
    session: Session = Depends(get_session),
):
    # Set RLS context for this transaction
    session.exec(text("SET app.user_id = :uid").bindparams(uid=user.id))

    # Try to fetch existing intake for this user (latest)
    existing = session.exec(
        select(Intake).where(Intake.user_id == user.id).order_by(Intake.id.desc()).limit(1)
    ).first()

    now_fields = {k: v for k, v in payload.dict().items() if v is not None}

    if existing:
        # Update existing
        for k, v in now_fields.items():
            setattr(existing, k, v)
        # Always touch updated_at
        from datetime import datetime as _dt
        existing.updated_at = _dt.utcnow()
        session.add(existing)
        session.flush()
        session.commit()
        row = existing
    else:
        # Create new
        from datetime import datetime as _dt
        row = Intake(user_id=user.id, **now_fields)
        # SQLModel defaults set created_at/updated_at; ensure updated_at touches now
        row.updated_at = _dt.utcnow()
        session.add(row)
        session.flush()
        session.commit()
    session.exec(text("RESET app.user_id"));
    session.exec(text("RESET app.user_id"));

    return {
        "id": row.id,
        "user_id": row.user_id,
        "name": row.name,
        "age": row.age,
        "sex": row.sex,
        "height_in": row.height_in,
        "weight_lb": row.weight_lb,
        "diabetic": row.diabetic,
        "conditions": row.conditions,
        "meds": row.meds,
        "goals": row.goals,
        "zip": row.zip,
        "gym": row.gym,
        "food_notes": getattr(row, "food_notes", None),
        "workout_notes": getattr(row, "workout_notes", None),
        "created_at": row.created_at.isoformat() if row.created_at else None,
        "updated_at": row.updated_at.isoformat() if row.updated_at else None,
    }


# ---------- Rationalize (derive structured plan prefs from Intake) ----------
class RationalizeOut(BaseModel):
    diet_label: str
    meals_per_day: int
    meal_times: List[str]
    carb_target_g: Optional[int] = None
    protein_target_g: Optional[int] = None
    kcal_target: Optional[int] = None
    notices: List[str] = []
    warnings: List[str] = []
    safety_required: bool = False

def _parse_goal_rate(goals: Optional[str]) -> Optional[float]:
    if not goals:
        return None
    s = goals.lower()
    import re
    m = re.search(r"lose\s+(\d+(?:\.\d+)?)\s*(lb|pounds?)", s)
    if not m: 
        m = re.search(r"(\d+(?:\.\d+)?)\s*(lb|pounds?)\s*(per|/)\s*(week|wk)", s)
        if m:
            try: return float(m.group(1))
            except: return None
        return None
    total = float(m.group(1))
    m2 = re.search(r"in\s+(\d+)\s*(weeks?|wks?)", s)
    if m2:
        weeks = int(m2.group(1))
        if weeks>0: 
            return total/weeks
    return None

def _heuristic_rationalize(intake: Intake) -> RationalizeOut:
    # Defaults
    meals_per_day = 2
    meal_times = ["12:00", "18:00"]
    diet_bits = []
    notices, warnings = [], []
    safety_required = False
    carb_target_g = None
    protein_target_g = None
    kcal_target = None

    # Aggressiveness check
    rate = _parse_goal_rate(getattr(intake, "goals", None) or "")
    if rate and rate > 2.0:
        warnings.append(f"Requested loss rate ~{rate:.1f} lb/week exceeds common safe range (≤2 lb/week).")
        safety_required = True

    # Diabetes / lower-carb tilt
    if getattr(intake, "diabetic", None) or (getattr(intake, "conditions", "") or "").lower().find("diab")>=0:
        diet_bits.append("lower‑carb")
        carb_target_g = 75  # conservative default; tuned later by LLM if available

    # Protein target (~1.6 g/kg)
    try:
        wt_lb = float(getattr(intake, "weight_lb") or 0)
        wt_kg = wt_lb / 2.20462 if wt_lb else None
        if wt_kg:
            protein_target_g = int(round(wt_kg * 1.6))
    except Exception:
        pass

    # Meals/day hints from notes
    notes = (getattr(intake, "food_notes", "") or "") + " " + (getattr(intake, "workout_notes", "") or "")
    s = notes.lower()
    if "6 small" in s or "6 meals" in s:
        meals_per_day = 6
        meal_times = ["08:00","10:30","13:00","15:30","18:00","20:30"]
        diet_bits.append("frequent small meals")
    elif "3 meals" in s or "three meals" in s:
        meals_per_day = 3
        meal_times = ["08:00","12:30","18:30"]
        diet_bits.append("no‑IF 3/day")
    elif "2 meals" in s or "two meals" in s or "if" in s or "intermittent fasting" in s:
        meals_per_day = 2
        meal_times = ["12:00","18:00"]
        diet_bits.append("IF 16:8 (2/day)")
    # Else keep defaults

    # Calorie target very rough (only when weight present)
    try:
        ht_in = float(getattr(intake, "height_in") or 0)
        if wt_lb and ht_in and wt_lb>0 and ht_in>0:
            bmi = (wt_lb / (ht_in*ht_in)) * 703.0
            # set kcal target loosely based on weight with modest deficit
            kcal_target = int(round(10*wt_lb + 6*ht_in - 5*40 - 200))  # Harris-Benedict-ish rough
            notices.append(f"Approx BMI {bmi:.1f}. Calories are heuristic and will be refined.")
    except Exception:
        pass

    diet_label = ("; ".join(diet_bits) if diet_bits else "balanced") + f", {meals_per_day} meals/day"
    return RationalizeOut(
        diet_label=diet_label,
        meals_per_day=meals_per_day,
        meal_times=meal_times,
        carb_target_g=carb_target_g,
        protein_target_g=protein_target_g,
        kcal_target=kcal_target,
        notices=notices,
        warnings=warnings,
        safety_required=safety_required,
    )

@router.post("/intake/rationalize")
def rationalize_intake(
    user: User = Depends(get_current_user),
    session: Session = Depends(get_session),
):
    # Set RLS context
    session.exec(text("SET app.user_id = :uid").bindparams(uid=user.id))
    try:
        row = session.exec(
            select(Intake).where(Intake.user_id == user.id).order_by(Intake.id.desc()).limit(1)
        ).first()
        if not row:
            raise HTTPException(status_code=404, detail="No intake found for user")
        r = _heuristic_rationalize(row)
        return r.dict()
    finally:
        session.exec(text("RESET app.user_id"))

# ---------- Plans: generate weekly plan (optionally persist as Meal + MealItems) ----------
class Ingredient(BaseModel):
    name: str
    quantity: Optional[confloat(ge=0)] = None
    unit: Optional[str] = None

class RecipeOut(BaseModel):
    time: str
    title: str
    kcal: Optional[int] = None
    carbs: Optional[int] = None
    protein: Optional[int] = None
    fat: Optional[int] = None
    ingredients: List[Ingredient] = []
    steps: List[str] = []

class DayPlan(BaseModel):
    date: str  # YYYY-MM-DD
    meals: List[RecipeOut]

class GeneratePlanIn(BaseModel):
    start: Optional[str] = None            # YYYY-MM-DD
    days: conint(ge=1, le=14) = 7
    persist: bool = True
    confirm: bool = False                  # must be true if safety_required
    include_recipes: bool = True

def _mk_recipe(title:str, time_str:str, kcal=None, carbs=None, protein=None, fat=None, ing=None, steps=None) -> RecipeOut:
    return RecipeOut(
        time=time_str, title=title, kcal=kcal, carbs=carbs, protein=protein, fat=fat,
        ingredients=[Ingredient(name=i[0], quantity=(i[1] if len(i)>1 else None), unit=(i[2] if len(i)>2 else None)) for i in (ing or [])],
        steps=steps or []
    )

_DEFAULT_MENU = [
    ("Egg scramble", [( "Eggs", 4, "pcs"), ("Spinach", 2, "cups"), ("Olive oil", 1, "tbsp")],
     ["Whisk eggs", "Sauté spinach in oil", "Add eggs; cook to set."]),
    ("Greek yogurt + walnuts", [("Greek yogurt", 1, "cup"), ("Walnuts", 1, "oz"), ("Berries", 0.5, "cup")],
     ["Combine all in a bowl."]),
    ("Tuna avocado boats", [("Canned tuna", 1, "can"), ("Avocado",1,"pcs"), ("Lemon",0.25,"pcs")],
     ["Mash avocado; mix tuna with lemon; fill avocado halves."]),
    ("Protein shake", [("Whey isolate",1,"scoop"),("Unsweetened almond milk",12,"oz"),("Ice",4,"cubes")],
     ["Blend until smooth."]),
    ("Cottage cheese bowl", [("Cottage cheese",1,"cup"),("Cucumber",0.5,"pcs"),("Everything seasoning",1,"tsp")],
     ["Dice cucumber, top the bowl, season."]),
    ("Chicken Caesar salad", [("Romaine",2,"cups"),("Chicken breast",6,"oz"),("Parmesan",2,"tbsp"),("Caesar dressing",2,"tbsp")],
     ["Grill or sear chicken; toss with romaine, dressing, parmesan."]),
    ("Grilled chicken + salad", [("Chicken breast",8,"oz"),("Mixed greens",2,"cups"),("Vinaigrette",2,"tbsp")],
     ["Grill chicken; dress salad; serve."]),
    ("Beef stir-fry (cauli rice)", [("Beef strips",6,"oz"),("Mixed veg",2,"cups"),("Soy sauce",1,"tbsp"),("Cauli rice",1.5,"cups")],
     ["Stir-fry beef/veg; steam cauli rice; combine."]),
    ("Turkey lettuce tacos", [("Ground turkey",6,"oz"),("Lettuce leaves",6,"pcs"),("Salsa",2,"tbsp"),("Cheese",1,"oz")],
     ["Cook turkey; assemble in lettuce leaves with toppings."]),
    ("Pork chops + green beans", [("Pork chop",8,"oz"),("Green beans",2,"cups"),("Butter",1,"tbsp")],
     ["Sear pork; sauté beans in butter; serve."]),
    ("Salmon + asparagus", [("Salmon",6,"oz"),("Asparagus",1,"bunch"),("Olive oil",1,"tbsp"),("Lemon",0.25,"pcs")],
     ["Roast salmon and asparagus; finish with lemon."]),
    ("Burger (no bun) + slaw", [("Ground beef patty",6,"oz"),("Cheddar",1,"oz"),("Coleslaw mix",2,"cups"),("Mayo",1,"tbsp")],
     ["Pan-sear patty; mix quick slaw; serve."]),
    ("Roast chicken + veg", [("Chicken thighs",8,"oz"),("Mixed veg",2,"cups"),("Olive oil",1,"tbsp")],
     ["Roast on a sheet pan until done."]),
]

def _build_menu_pairs():
    midday = [
        ("Egg scramble", 420, 6, 35, 27),
        ("Greek yogurt + walnuts", 380, 9, 28, 20),
        ("Tuna avocado boats", 430, 5, 32, 28),
        ("Protein shake", 350, 7, 30, 10),
        ("Cottage cheese bowl", 360, 8, 30, 12),
        ("Chicken Caesar salad", 480, 10, 42, 24),
        ("Chicken Caesar salad", 480, 10, 42, 24),
    ]
    dinner = [
        ("Grilled chicken + salad", 520, 10, 50, 22),
        ("Beef stir-fry (cauli rice)", 560, 11, 45, 28),
        ("Turkey lettuce tacos", 540, 12, 40, 26),
        ("Pork chops + green beans", 570, 9, 45, 32),
        ("Salmon + asparagus", 550, 6, 42, 28),
        ("Burger (no bun) + slaw", 590, 14, 35, 38),
        ("Roast chicken + veg", 560, 12, 46, 30),
    ]
    return midday, dinner

def _find_ingredients(title:str):
    for name, ing, steps in _DEFAULT_MENU:
        if name.lower()==title.lower():
            return ing, steps
    # fallback generic
    return [], ["Cook and serve."]

@router.post("/plans/generate")
def generate_plan(
    payload: GeneratePlanIn,
    user: User = Depends(get_current_user),
    session: Session = Depends(get_session),
):
    # Load intake for rationalization
    session.exec(text("SET app.user_id = :uid").bindparams(uid=user.id))
    try:
        intake = session.exec(
            select(Intake).where(Intake.user_id == user.id).order_by(Intake.id.desc()).limit(1)
        ).first()
        if not intake:
            raise HTTPException(status_code=404, detail="No intake found; fill About You first.")

        rz = _heuristic_rationalize(intake)
        if rz.safety_required and not payload.confirm:
            raise HTTPException(status_code=412, detail={
                "message": "Plan requires explicit confirmation due to aggressive goals.",
                "warnings": rz.warnings,
                "action": "Resubmit with { confirm: true } to proceed."
            })

        # Window
        start_date = _date.fromisoformat(payload.start) if payload.start else _dt.utcnow().date()
        days = int(payload.days or 7)
        meal_times = rz.meal_times[:]
        if rz.meals_per_day==2 and len(meal_times)<2:
            meal_times = ["12:00","18:00"]
        if rz.meals_per_day==3 and len(meal_times)<3:
            meal_times = ["08:00","12:30","18:30"]

        # Build plan (heuristics; LLM plug can refine later)
        midday, dinner = _build_menu_pairs()
        day_plans: List[DayPlan] = []
        for i in range(days):
            d = start_date + _td(days=i)
            meals: List[RecipeOut] = []
            if rz.meals_per_day==2:
                a = midday[i % len(midday)]
                b = dinner[i % len(dinner)]
                for (title,kcal,carbs,protein,fat), tt in [(a, meal_times[0]), (b, meal_times[1] if len(meal_times)>1 else "18:00")]:
                    ing, steps = _find_ingredients(title)
                    meals.append(_mk_recipe(title, tt, kcal=kcal, carbs=carbs, protein=protein, fat=fat, ing=ing, steps=steps))
            elif rz.meals_per_day==3:
                trio = (midday[i % len(midday)], midday[(i+1) % len(midday)], dinner[i % len(dinner)])
                for idx, (title,kcal,carbs,protein,fat) in enumerate([trio[0], trio[1], trio[2]]):
                    tt = meal_times[idx] if idx < len(meal_times) else ["08:00","12:30","18:30"][idx]
                    ing, steps = _find_ingredients(title)
                    meals.append(_mk_recipe(title, tt, kcal=kcal, carbs=carbs, protein=protein, fat=fat, ing=ing, steps=steps))
            else:
                # Fallback to 2/day template
                a = midday[i % len(midday)]
                b = dinner[i % len(dinner)]
                for (title,kcal,carbs,protein,fat), tt in [(a, "12:00"), (b, "18:00")]:
                    ing, steps = _find_ingredients(title)
                    meals.append(_mk_recipe(title, tt, kcal=kcal, carbs=carbs, protein=protein, fat=fat, ing=ing, steps=steps))

            day_plans.append(DayPlan(date=d.isoformat(), meals=meals))

        # Persist as Meal + MealItem when requested
        if payload.persist:
            for day in day_plans:
                for m in day.meals:
                    hh, mm = (m.time or "12:00").split(":")[0:2]
                    eaten_at = _dt.combine(_date.fromisoformat(day.date), _time(int(hh), int(mm)))
                    meal_row = Meal(user_id=user.id, name=m.title, eaten_at=eaten_at, total_calories=m.kcal)
                    session.add(meal_row)
                    session.flush()
                    for it in (m.ingredients or []):
                        mi = MealItem(meal_id=meal_row.id, name=it.name, calories=None, quantity=it.quantity, unit=it.unit)
                        session.add(mi)
            session.commit()

        # Build response and save plan JSON history
        resp = {
            "window": {"start": start_date.isoformat(), "end": (start_date + _td(days=days-1)).isoformat()},
            "rationalization": rz.dict(),
            "days": [d.dict() for d in day_plans],
            "persisted": bool(payload.persist),
            "created_at": _dt.utcnow().isoformat(),
        }
        try:
            _save_plan(user.id, start_date, resp)
        except Exception:
            pass
        return resp
    finally:
        session.exec(text("RESET app.user_id"))
# ---------- Plan History (file-backed per user) ----------
def _plans_dir(uid: int) -> str:
    d = os.path.join("data", "plans", f"user-{uid}")
    os.makedirs(d, exist_ok=True)
    return d

def _save_plan(uid: int, start_date: _date, payload: dict) -> str:
    d = _plans_dir(uid)
    fp = os.path.join(d, f"{start_date.isoformat()}.json")
    with open(fp, "w", encoding="utf-8") as f:
        json.dump(payload, f, ensure_ascii=False, indent=2)
    return fp


@router.get("/plans")
def list_plans(
    user: User = Depends(get_current_user),
):
    out = []
    d = _plans_dir(user.id)
    try:
        for name in sorted(os.listdir(d)):
            if not name.endswith(".json"): 
                continue
            start = name[:-5]
            try:
                with open(os.path.join(d, name), "r", encoding="utf-8") as f:
                    data = json.load(f)
                win = data.get("window", {})
                rz = data.get("rationalization", {}) or {}
                days = data.get("days", []) or []
                out.append({
                    "start": win.get("start", start),
                    "end": win.get("end", start),
                    "diet_label": rz.get("diet_label"),
                    "meals_per_day": rz.get("meals_per_day"),
                    "count_days": len(days),
                    "created_at": data.get("created_at"),
                })
            except Exception:
                out.append({"start": start, "end": start})
    except FileNotFoundError:
        pass
    return out

@router.get("/plans/{start}")
def get_plan(
    start: str,
    user: User = Depends(get_current_user),
):
    fp = os.path.join(_plans_dir(user.id), f"{start}.json")
    if not os.path.exists(fp):
        raise HTTPException(status_code=404, detail="Plan not found")
    with open(fp, "r", encoding="utf-8") as f:
        data = json.load(f)
    return data
