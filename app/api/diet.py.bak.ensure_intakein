from sqlalchemy import text
from typing import List, Optional, Dict, Tuple
from datetime import datetime
from pydantic import BaseModel, conint, confloat
from fastapi import APIRouter, Depends, HTTPException, Query
from sqlmodel import Session, select

from ..core.db import get_session
from ..core.security import get_current_user
from ..models import User, Meal, MealItem, GroceryItem, Intake
from typing import Any, Literal
from datetime import date as _date, time as _time, timedelta as _td, datetime as _dt
import os, json

router = APIRouter()

# ---------- Meals ----------
class MealItemIn(BaseModel):
    name: str
    calories: Optional[conint(ge=0)] = None
    quantity: Optional[confloat(ge=0)] = None
    unit: Optional[str] = None

class MealCreate(BaseModel):
    name: str
    eaten_at: Optional[datetime] = None
    items: List[MealItemIn] = []

@router.post("/meals", status_code=201)
def create_meal(payload: MealCreate, user: User = Depends(get_current_user), session: Session = Depends(get_session)):
    # Set RLS context for this transaction
    session.exec(text("SET app.user_id = :uid").bindparams(uid=user.id))
    try:
        meal = Meal(
            user_id=user.id,
            name=payload.name,
            eaten_at=payload.eaten_at or datetime.utcnow(),
            total_calories=(sum(i.calories or 0 for i in payload.items) if payload.items else None),
        )
        session.add(meal)
        session.flush()  # get meal.id before adding items

        for it in payload.items:
            mi = MealItem(meal_id=meal.id, name=it.name, calories=it.calories, quantity=it.quantity, unit=it.unit)
            session.add(mi)

        session.commit()
        return {"id": meal.id, "name": meal.name, "eaten_at": meal.eaten_at.isoformat(), "total_calories": meal.total_calories, "items": len(payload.items)}
    finally:
        session.exec(text("RESET app.user_id"))
@router.get("/meals")
def list_meals(
    user: User = Depends(get_current_user),
    session: Session = Depends(get_session),
    limit: int = Query(50, ge=1, le=100),
):
    # Set RLS context for this transaction so SELECT can see only this user's rows
    session.exec(text("SET app.user_id = :uid").bindparams(uid=user.id))
    try:
        meals = session.exec(
            select(Meal).where(Meal.user_id == user.id).order_by(Meal.eaten_at.desc()).limit(limit)
        ).all()

        by_meal = {}
        if meals:
            meal_ids = [m.id for m in meals]
            items = session.exec(select(MealItem).where(MealItem.meal_id.in_(meal_ids))).all()
            for it in items:
                by_meal.setdefault(it.meal_id, []).append(it)

        out = []
        for m in meals:
            out.append({
                "id": m.id,
                "name": m.name,
                "eaten_at": m.eaten_at.isoformat(),
                "total_calories": m.total_calories,
                "items": [{"name": it.name, "calories": it.calories, "qty": it.quantity, "unit": it.unit} for it in by_meal.get(m.id, [])]
            })
        return out
    finally:
        session.exec(text("RESET app.user_id"))

# ---------- Groceries ----------# ---------- Groceries ----------
class GroceryIn(BaseModel):
    name: str
    quantity: Optional[confloat(ge=0)] = None
    unit: Optional[str] = None

class GroceryUpdate(BaseModel):
    purchased: bool

@router.post("/groceries", status_code=201)
def add_grocery(payload: GroceryIn, user: User = Depends(get_current_user), session: Session = Depends(get_session)):
    # Set RLS context
    session.exec(text("SET app.user_id = :uid").bindparams(uid=user.id))
    try:
        g = GroceryItem(user_id=user.id, name=payload.name, quantity=payload.quantity, unit=payload.unit, purchased=False)
        session.add(g)
        session.commit()
        return {"id": g.id, "name": g.name, "quantity": g.quantity, "unit": g.unit, "purchased": g.purchased}
    finally:
        session.exec(text("RESET app.user_id"))


@router.get("/groceries")
def list_groceries(
    user: User = Depends(get_current_user),
    session: Session = Depends(get_session),
    only_open: bool = Query(True),
):
    # Set RLS context
    session.exec(text("SET app.user_id = :uid").bindparams(uid=user.id))
    try:
        q = select(GroceryItem).where(GroceryItem.user_id == user.id)
        if only_open:
            q = q.where(GroceryItem.purchased == False)  # noqa: E712
        rows = session.exec(q.order_by(GroceryItem.created_at.desc())).all()
        # Include optional store/price fields if columns exist (safe via getattr)
        return [{
            "id": r.id,
            "name": r.name,
            "quantity": r.quantity,
            "unit": r.unit,
            "purchased": r.purchased,
            "store": getattr(r, "store", None),
            "unit_price": getattr(r, "unit_price", None),
            "total_price": getattr(r, "total_price", None),
            "created_at": r.created_at.isoformat()
        } for r in rows]
    finally:
        session.exec(text("RESET app.user_id"))

@router.patch("/groceries/{item_id}")
def update_grocery(item_id: int, payload: GroceryUpdate, user: User = Depends(get_current_user), session: Session = Depends(get_session)):
    # Set RLS context
    session.exec(text("SET app.user_id = :uid").bindparams(uid=user.id))
    try:
        g = session.get(GroceryItem, item_id)
        if not g or g.user_id != user.id:
            raise HTTPException(status_code=404, detail="Item not found")
        g.purchased = payload.purchased
        session.add(g)
        session.commit()
        return {"id": g.id, "name": g.name, "purchased": g.purchased}
    finally:
        session.exec(text("RESET app.user_id"))



@router.post("/groceries/sync_from_meals")
def sync_groceries_from_meals(
    start: Optional[str] = Query(None, description="YYYY-MM-DD"),
    end: Optional[str] = Query(None, description="YYYY-MM-DD"),
    persist: bool = Query(True),
    clear_existing: bool = Query(False),
    seed_if_empty: bool = Query(True, description="If no meals exist in window, use a default 7-day, 2-meals/day plan and (when persist) seed meals."),
    user: User = Depends(get_current_user),
    session: Session = Depends(get_session),
):
    """
    Aggregate grocery items from meals in [start, end] (inclusive).
    - Uses real MealItem rows when present.
    - If a meal has no items, falls back to default ingredients by dish name.
    - If there are no meals at all in the window and seed_if_empty=True, it uses
      a default 7-day, 2-meals/day schedule and (if persist) seeds Meal rows.
    When persist=true, writes to grocery_items (respecting RLS).
    """
    from datetime import datetime as _dt, timedelta as _td, date as _date, time as _time

    # Window [start_dt, end_excl)
    today = _dt.utcnow().date()
    sdate = _date.fromisoformat(start) if start else today
    edate = _date.fromisoformat(end) if end else (sdate + _td(days=6))
    start_dt = _dt.combine(sdate, _time(0,0))
    end_excl = _dt.combine(edate + _td(days=1), _time(0,0))

    # Default ingredient fallback by dish name
    fallback = {
        "Chicken Caesar Bowl": [("Chicken breast", 1.5, "lb"), ("Romaine", 2, "heads"), ("Parmesan", 1, "cup"), ("Caesar dressing", 1, "bottle")],
        "Salmon & Asparagus": [("Salmon fillets", 4, "pcs"), ("Asparagus", 2, "bunch"), ("Lemon", 2, "pcs")],
        "Turkey Lettuce Wraps": [("Ground turkey", 1, "lb"), ("Lettuce", 2, "heads"), ("Bell peppers", 2, "pcs")],
        "Lean Turkey Chili": [("Ground turkey", 2, "lb"), ("Diced tomatoes", 2, "cans"), ("Kidney beans", 2, "cans"), ("Chili seasoning", 1, "packet")],
        "Tuna Nicoise": [("Canned tuna", 4, "cans"), ("Green beans", 1, "lb"), ("Eggs", 6, "pcs"), ("Olives", 1, "jar")],
        "Baked Cod & Broccoli": [("Cod fillets", 4, "pcs"), ("Broccoli", 2, "heads"), ("Olive oil", 1, "bottle")],
        "Greek Chicken Bowl": [("Chicken breast", 1.5, "lb"), ("Cucumber", 2, "pcs"), ("Tomatoes", 4, "pcs"), ("Feta", 1, "block")],
        "Turkey Meatballs & Veg": [("Ground turkey", 1.5, "lb"), ("Marinara", 1, "jar"), ("Zucchini", 3, "pcs"), ("Parmesan", 1, "cup")],
        "Beef & Veg Stir-Fry": [("Beef strips", 1.5, "lb"), ("Broccoli", 1, "head"), ("Bell peppers", 2, "pcs"), ("Soy sauce", 1, "bottle")],
        "Chicken Fajita Bowl": [("Chicken breast", 1.5, "lb"), ("Bell peppers", 3, "pcs"), ("Onions", 2, "pcs"), ("Fajita seasoning", 1, "packet")],
        "Shrimp & Zoodles": [("Shrimp", 2, "lb"), ("Zucchini", 4, "pcs"), ("Garlic", 1, "bulb")],
        "Steak & Big Salad": [("Steak", 2, "lb"), ("Mixed greens", 2, "bags"), ("Cherry tomatoes", 2, "pints")],
        "Egg Roll in a Bowl": [("Ground pork", 1, "lb"), ("Cabbage", 1, "head"), ("Soy sauce", 1, "bottle")],
        "Garlic Chicken & Veg": [("Chicken thighs", 1.5, "lb"), ("Green beans", 1, "lb"), ("Garlic", 1, "bulb")],
    }
    default_meals1 = ["Chicken Caesar Bowl","Turkey Lettuce Wraps","Tuna Nicoise","Greek Chicken Bowl","Beef & Veg Stir-Fry","Shrimp & Zoodles","Egg Roll in a Bowl"]
    default_meals2 = ["Salmon & Asparagus","Lean Turkey Chili","Baked Cod & Broccoli","Turkey Meatballs & Veg","Chicken Fajita Bowl","Steak & Big Salad","Garlic Chicken & Veg"]

    # Set RLS context
    session.exec(text("SET app.user_id = :uid").bindparams(uid=user.id))
    try:
        meals = session.exec(
            select(Meal)
            .where(Meal.user_id == user.id)
            .where(Meal.eaten_at >= start_dt, Meal.eaten_at < end_excl)
            .order_by(Meal.eaten_at.asc())
        ).all()

        agg = {}
        def add(name, qty, unit):
            key = (name.strip(), (unit or "").strip())
            agg[key] = agg.get(key, 0.0) + float(qty if qty is not None else 1.0)

        if not meals and seed_if_empty:
            days = (edate - sdate).days + 1
            schedule = []
            for i in range(days):
                day = sdate + _td(days=i)
                d1 = default_meals1[i % len(default_meals1)]
                d2 = default_meals2[i % len(default_meals2)]
                schedule.append((day, d1, d2))

            # Seed meal rows (for UI visibility) and aggregate fallback groceries
            if persist:
                for day, d1, d2 in schedule:
                    session.add(Meal(user_id=user.id, name=f"Meal 1 - {d1}", eaten_at=_dt.combine(day, _time(12,30))))
                    session.add(Meal(user_id=user.id, name=f"Meal 2 - {d2}", eaten_at=_dt.combine(day, _time(18,30))))
                session.flush()

            for _, d1, d2 in schedule:
                for dish in (d1, d2):
                    for (n,q,u) in fallback.get(dish, []):
                        add(n,q,u)

        else:
            # Use real items when present; otherwise fallback by dish name
            meal_ids = [m.id for m in meals] if meals else []
            items_by_meal = {}
            if meal_ids:
                mis = session.exec(select(MealItem).where(MealItem.meal_id.in_(meal_ids))).all()
                for it in mis:
                    items_by_meal.setdefault(it.meal_id, []).append(it)

            for m in meals:
                real_items = items_by_meal.get(m.id, [])
                if real_items:
                    for it in real_items:
                        add(it.name, it.quantity if it.quantity is not None else 1.0, it.unit)
                else:
                    dish = m.name.split(" - ", 1)[-1]
                    for (n,q,u) in fallback.get(dish, []):
                        add(n,q,u)

        out = [{"name": k[0], "quantity": round(v, 2), "unit": (k[1] or None)} for k, v in sorted(agg.items(), key=lambda x: x[0][0].lower())]

        if persist and out:
            if clear_existing:
                session.exec(text("DELETE FROM grocery_items WHERE user_id = :uid AND (purchased IS NULL OR purchased = false)").bindparams(uid=user.id))
            for row in out:
                session.add(GroceryItem(user_id=user.id, name=row["name"], quantity=row["quantity"], unit=row["unit"], purchased=False))
            session.commit()

        return {"window": {"start": sdate.isoformat(), "end": edate.isoformat()}, "count": len(out), "items": out}
    finally:
        session.exec(text("RESET app.user_id"))
# ---------- Intake (DB-backed with RLS) ----------

@router.get("/intake")
def get_intake(
    user: User = Depends(get_current_user),
    session: Session = Depends(get_session),
):
    # Set RLS context for this transaction
    session.exec(text("SET app.user_id = :uid").bindparams(uid=user.id))
    row = session.exec(
        select(Intake).where(Intake.user_id == user.id).order_by(Intake.id.desc()).limit(1)
    ).first()
    if not row:
        return None
    session.exec(text("RESET app.user_id"));
    session.exec(text("RESET app.user_id"));
    return {
        "id": row.id,
        "user_id": row.user_id,
        "name": row.name,
        "age": row.age,
        "sex": row.sex,
        "height_in": row.height_in,
        "weight_lb": row.weight_lb,
        "diabetic": row.diabetic,
        "conditions": row.conditions,
        "meds": row.meds,
        "goals": row.goals,
        "zip": row.zip,
        "gym": row.gym,
        "food_notes": getattr(row, "food_notes", None),
        "workout_notes": getattr(row, "workout_notes", None),
        "created_at": row.created_at.isoformat() if row.created_at else None,
        "updated_at": row.updated_at.isoformat() if row.updated_at else None,
    }

@router.post("/intake", status_code=201)
def upsert_intake(
    payload: IntakeIn,
    user: User = Depends(get_current_user),
    session: Session = Depends(get_session),
):
    # Set RLS context for this transaction
    session.exec(text("SET app.user_id = :uid").bindparams(uid=user.id))

    # Try to fetch existing intake for this user (latest)
    existing = session.exec(
        select(Intake).where(Intake.user_id == user.id).order_by(Intake.id.desc()).limit(1)
    ).first()

    now_fields = {k: v for k, v in payload.dict().items() if v is not None}

    if existing:
        # Update existing
        for k, v in now_fields.items():
            setattr(existing, k, v)
        # Always touch updated_at
        from datetime import datetime as _dt
        existing.updated_at = _dt.utcnow()
        session.add(existing)
        session.flush()
        session.commit()
        row = existing
    else:
        # Create new
        from datetime import datetime as _dt
        row = Intake(user_id=user.id, **now_fields)
        # SQLModel defaults set created_at/updated_at; ensure updated_at touches now
        row.updated_at = _dt.utcnow()
        session.add(row)
        session.flush()
        session.commit()
    session.exec(text("RESET app.user_id"));
    session.exec(text("RESET app.user_id"));

    return {
        "id": row.id,
        "user_id": row.user_id,
        "name": row.name,
        "age": row.age,
        "sex": row.sex,
        "height_in": row.height_in,
        "weight_lb": row.weight_lb,
        "diabetic": row.diabetic,
        "conditions": row.conditions,
        "meds": row.meds,
        "goals": row.goals,
        "zip": row.zip,
        "gym": row.gym,
        "food_notes": getattr(row, "food_notes", None),
        "workout_notes": getattr(row, "workout_notes", None),
        "created_at": row.created_at.isoformat() if row.created_at else None,
        "updated_at": row.updated_at.isoformat() if row.updated_at else None,
    }


# ---------- Rationalize (derive structured plan prefs from Intake) ----------
class RationalizeOut(BaseModel):
    diet_label: str
    meals_per_day: int
    meal_times: List[str]
    carb_target_g: Optional[int] = None
    protein_target_g: Optional[int] = None
    kcal_target: Optional[int] = None
    notices: List[str] = []
    warnings: List[str] = []
    safety_required: bool = False

def _parse_goal_rate(goals: Optional[str]) -> Optional[float]:
    if not goals:
        return None
    s = goals.lower()
    import re
    m = re.search(r"lose\s+(\d+(?:\.\d+)?)\s*(lb|pounds?)", s)
    if not m: 
        m = re.search(r"(\d+(?:\.\d+)?)\s*(lb|pounds?)\s*(per|/)\s*(week|wk)", s)
        if m:
            try: return float(m.group(1))
            except: return None
        return None
    total = float(m.group(1))
    m2 = re.search(r"in\s+(\d+)\s*(weeks?|wks?)", s)
    if m2:
        weeks = int(m2.group(1))
        if weeks>0: 
            return total/weeks
    return None

def _heuristic_rationalize(intake: Intake) -> RationalizeOut:
    # Defaults
    meals_per_day = 2
    meal_times = ["12:00", "18:00"]
    diet_bits = []
    notices, warnings = [], []
    safety_required = False
    carb_target_g = None
    protein_target_g = None
    kcal_target = None

    # Aggressiveness check
    rate = _parse_goal_rate(getattr(intake, "goals", None) or "")
    if rate and rate > 2.0:
        warnings.append(f"Requested loss rate ~{rate:.1f} lb/week exceeds common safe range (≤2 lb/week).")
        safety_required = True

    # Diabetes / lower-carb tilt
    if getattr(intake, "diabetic", None) or (getattr(intake, "conditions", "") or "").lower().find("diab")>=0:
        diet_bits.append("lower‑carb")
        carb_target_g = 75  # conservative default; tuned later by LLM if available

    # Protein target (~1.6 g/kg)
    try:
        wt_lb = float(getattr(intake, "weight_lb") or 0)
        wt_kg = wt_lb / 2.20462 if wt_lb else None
        if wt_kg:
            protein_target_g = int(round(wt_kg * 1.6))
    except Exception:
        pass

    # Meals/day hints from notes
    notes = (getattr(intake, "food_notes", "") or "") + " " + (getattr(intake, "workout_notes", "") or "")
    s = notes.lower()
    if "6 small" in s or "6 meals" in s:
        meals_per_day = 6
        meal_times = ["08:00","10:30","13:00","15:30","18:00","20:30"]
        diet_bits.append("frequent small meals")
    elif "3 meals" in s or "three meals" in s:
        meals_per_day = 3
        meal_times = ["08:00","12:30","18:30"]
        diet_bits.append("no‑IF 3/day")
    elif "2 meals" in s or "two meals" in s or "if" in s or "intermittent fasting" in s:
        meals_per_day = 2
        meal_times = ["12:00","18:00"]
        diet_bits.append("IF 16:8 (2/day)")
    # Else keep defaults

    # Calorie target very rough (only when weight present)
    try:
        ht_in = float(getattr(intake, "height_in") or 0)
        if wt_lb and ht_in and wt_lb>0 and ht_in>0:
            bmi = (wt_lb / (ht_in*ht_in)) * 703.0
            # set kcal target loosely based on weight with modest deficit
            kcal_target = int(round(10*wt_lb + 6*ht_in - 5*40 - 200))  # Harris-Benedict-ish rough
            notices.append(f"Approx BMI {bmi:.1f}. Calories are heuristic and will be refined.")
    except Exception:
        pass

    diet_label = ("; ".join(diet_bits) if diet_bits else "balanced") + f", {meals_per_day} meals/day"
    return RationalizeOut(
        diet_label=diet_label,
        meals_per_day=meals_per_day,
        meal_times=meal_times,
        carb_target_g=carb_target_g,
        protein_target_g=protein_target_g,
        kcal_target=kcal_target,
        notices=notices,
        warnings=warnings,
        safety_required=safety_required,
    )

@router.post("/intake/rationalize")
def rationalize_intake(
    user: User = Depends(get_current_user),
    session: Session = Depends(get_session),
):
    # Set RLS context
    session.exec(text("SET app.user_id = :uid").bindparams(uid=user.id))
    try:
        row = session.exec(
            select(Intake).where(Intake.user_id == user.id).order_by(Intake.id.desc()).limit(1)
        ).first()
        if not row:
            raise HTTPException(status_code=404, detail="No intake found for user")
        r = _heuristic_rationalize(row)
        return r.dict()
    finally:
        session.exec(text("RESET app.user_id"))

# ---------- Plans: generate weekly plan (optionally persist as Meal + MealItems) ----------
class Ingredient(BaseModel):
    name: str
    quantity: Optional[confloat(ge=0)] = None
    unit: Optional[str] = None

class RecipeOut(BaseModel):
    time: str
    title: str
    kcal: Optional[int] = None
    carbs: Optional[int] = None
    protein: Optional[int] = None
    fat: Optional[int] = None
    ingredients: List[Ingredient] = []
    steps: List[str] = []

class DayPlan(BaseModel):
    date: str  # YYYY-MM-DD
    meals: List[RecipeOut]

class GeneratePlanIn(BaseModel):
    start: Optional[str] = None            # YYYY-MM-DD
    days: conint(ge=1, le=14) = 7
    persist: bool = True
    confirm: bool = False                  # must be true if safety_required
    include_recipes: bool = True

def _mk_recipe(title:str, time_str:str, kcal=None, carbs=None, protein=None, fat=None, ing=None, steps=None) -> RecipeOut:
    return RecipeOut(
        time=time_str, title=title, kcal=kcal, carbs=carbs, protein=protein, fat=fat,
        ingredients=[Ingredient(name=i[0], quantity=(i[1] if len(i)>1 else None), unit=(i[2] if len(i)>2 else None)) for i in (ing or [])],
        steps=steps or []
    )

_DEFAULT_MENU = [
    ("Egg scramble", [( "Eggs", 4, "pcs"), ("Spinach", 2, "cups"), ("Olive oil", 1, "tbsp")],
     ["Whisk eggs", "Sauté spinach in oil", "Add eggs; cook to set."]),
    ("Greek yogurt + walnuts", [("Greek yogurt", 1, "cup"), ("Walnuts", 1, "oz"), ("Berries", 0.5, "cup")],
     ["Combine all in a bowl."]),
    ("Tuna avocado boats", [("Canned tuna", 1, "can"), ("Avocado",1,"pcs"), ("Lemon",0.25,"pcs")],
     ["Mash avocado; mix tuna with lemon; fill avocado halves."]),
    ("Protein shake", [("Whey isolate",1,"scoop"),("Unsweetened almond milk",12,"oz"),("Ice",4,"cubes")],
     ["Blend until smooth."]),
    ("Cottage cheese bowl", [("Cottage cheese",1,"cup"),("Cucumber",0.5,"pcs"),("Everything seasoning",1,"tsp")],
     ["Dice cucumber, top the bowl, season."]),
    ("Chicken Caesar salad", [("Romaine",2,"cups"),("Chicken breast",6,"oz"),("Parmesan",2,"tbsp"),("Caesar dressing",2,"tbsp")],
     ["Grill or sear chicken; toss with romaine, dressing, parmesan."]),
    ("Grilled chicken + salad", [("Chicken breast",8,"oz"),("Mixed greens",2,"cups"),("Vinaigrette",2,"tbsp")],
     ["Grill chicken; dress salad; serve."]),
    ("Beef stir-fry (cauli rice)", [("Beef strips",6,"oz"),("Mixed veg",2,"cups"),("Soy sauce",1,"tbsp"),("Cauli rice",1.5,"cups")],
     ["Stir-fry beef/veg; steam cauli rice; combine."]),
    ("Turkey lettuce tacos", [("Ground turkey",6,"oz"),("Lettuce leaves",6,"pcs"),("Salsa",2,"tbsp"),("Cheese",1,"oz")],
     ["Cook turkey; assemble in lettuce leaves with toppings."]),
    ("Pork chops + green beans", [("Pork chop",8,"oz"),("Green beans",2,"cups"),("Butter",1,"tbsp")],
     ["Sear pork; sauté beans in butter; serve."]),
    ("Salmon + asparagus", [("Salmon",6,"oz"),("Asparagus",1,"bunch"),("Olive oil",1,"tbsp"),("Lemon",0.25,"pcs")],
     ["Roast salmon and asparagus; finish with lemon."]),
    ("Burger (no bun) + slaw", [("Ground beef patty",6,"oz"),("Cheddar",1,"oz"),("Coleslaw mix",2,"cups"),("Mayo",1,"tbsp")],
     ["Pan-sear patty; mix quick slaw; serve."]),
    ("Roast chicken + veg", [("Chicken thighs",8,"oz"),("Mixed veg",2,"cups"),("Olive oil",1,"tbsp")],
     ["Roast on a sheet pan until done."]),
]

def _build_menu_pairs():
    midday = [
        ("Egg scramble", 420, 6, 35, 27),
        ("Greek yogurt + walnuts", 380, 9, 28, 20),
        ("Tuna avocado boats", 430, 5, 32, 28),
        ("Protein shake", 350, 7, 30, 10),
        ("Cottage cheese bowl", 360, 8, 30, 12),
        ("Chicken Caesar salad", 480, 10, 42, 24),
        ("Chicken Caesar salad", 480, 10, 42, 24),
    ]
    dinner = [
        ("Grilled chicken + salad", 520, 10, 50, 22),
        ("Beef stir-fry (cauli rice)", 560, 11, 45, 28),
        ("Turkey lettuce tacos", 540, 12, 40, 26),
        ("Pork chops + green beans", 570, 9, 45, 32),
        ("Salmon + asparagus", 550, 6, 42, 28),
        ("Burger (no bun) + slaw", 590, 14, 35, 38),
        ("Roast chicken + veg", 560, 12, 46, 30),
    ]
    return midday, dinner

def _find_ingredients(title:str):
    for name, ing, steps in _DEFAULT_MENU:
        if name.lower()==title.lower():
            return ing, steps
    # fallback generic
    return [], ["Cook and serve."]

@router.post("/plans/generate")
def generate_plan(
    payload: GeneratePlanIn,
    user: User = Depends(get_current_user),
    session: Session = Depends(get_session),
):
    # Load intake for rationalization
    session.exec(text("SET app.user_id = :uid").bindparams(uid=user.id))
    try:
        intake = session.exec(
            select(Intake).where(Intake.user_id == user.id).order_by(Intake.id.desc()).limit(1)
        ).first()
        if not intake:
            raise HTTPException(status_code=404, detail="No intake found; fill About You first.")

        rz = _heuristic_rationalize(intake)
        if rz.safety_required and not payload.confirm:
            raise HTTPException(status_code=412, detail={
                "message": "Plan requires explicit confirmation due to aggressive goals.",
                "warnings": rz.warnings,
                "action": "Resubmit with { confirm: true } to proceed."
            })

        # Window
        start_date = _date.fromisoformat(payload.start) if payload.start else _dt.utcnow().date()
        days = int(payload.days or 7)
        meal_times = rz.meal_times[:]
        if rz.meals_per_day==2 and len(meal_times)<2:
            meal_times = ["12:00","18:00"]
        if rz.meals_per_day==3 and len(meal_times)<3:
            meal_times = ["08:00","12:30","18:30"]

        # Build plan (heuristics; LLM plug can refine later)
        midday, dinner = _build_menu_pairs()
        day_plans: List[DayPlan] = []
        for i in range(days):
            d = start_date + _td(days=i)
            meals: List[RecipeOut] = []
            if rz.meals_per_day==2:
                a = midday[i % len(midday)]
                b = dinner[i % len(dinner)]
                for (title,kcal,carbs,protein,fat), tt in [(a, meal_times[0]), (b, meal_times[1] if len(meal_times)>1 else "18:00")]:
                    ing, steps = _find_ingredients(title)
                    meals.append(_mk_recipe(title, tt, kcal=kcal, carbs=carbs, protein=protein, fat=fat, ing=ing, steps=steps))
            elif rz.meals_per_day==3:
                trio = (midday[i % len(midday)], midday[(i+1) % len(midday)], dinner[i % len(dinner)])
                for idx, (title,kcal,carbs,protein,fat) in enumerate([trio[0], trio[1], trio[2]]):
                    tt = meal_times[idx] if idx < len(meal_times) else ["08:00","12:30","18:30"][idx]
                    ing, steps = _find_ingredients(title)
                    meals.append(_mk_recipe(title, tt, kcal=kcal, carbs=carbs, protein=protein, fat=fat, ing=ing, steps=steps))
            else:
                # Fallback to 2/day template
                a = midday[i % len(midday)]
                b = dinner[i % len(dinner)]
                for (title,kcal,carbs,protein,fat), tt in [(a, "12:00"), (b, "18:00")]:
                    ing, steps = _find_ingredients(title)
                    meals.append(_mk_recipe(title, tt, kcal=kcal, carbs=carbs, protein=protein, fat=fat, ing=ing, steps=steps))

            day_plans.append(DayPlan(date=d.isoformat(), meals=meals))

        # Persist as Meal + MealItem when requested
        if payload.persist:
            for day in day_plans:
                for m in day.meals:
                    hh, mm = (m.time or "12:00").split(":")[0:2]
                    eaten_at = _dt.combine(_date.fromisoformat(day.date), _time(int(hh), int(mm)))
                    meal_row = Meal(user_id=user.id, name=m.title, eaten_at=eaten_at, total_calories=m.kcal)
                    session.add(meal_row)
                    session.flush()
                    for it in (m.ingredients or []):
                        mi = MealItem(meal_id=meal_row.id, name=it.name, calories=None, quantity=it.quantity, unit=it.unit)
                        session.add(mi)
            session.commit()

        # Build response and save plan JSON history
        resp = {
            "window": {"start": start_date.isoformat(), "end": (start_date + _td(days=days-1)).isoformat()},
            "rationalization": rz.dict(),
            "days": [d.dict() for d in day_plans],
            "persisted": bool(payload.persist),
            "created_at": _dt.utcnow().isoformat(),
        }
        try:
            _save_plan(user.id, start_date, resp)
        except Exception:
            pass
        return resp
    finally:
        session.exec(text("RESET app.user_id"))
# ---------- Plan History (file-backed per user) ----------
def _plans_dir(uid: int) -> str:
    d = os.path.join("data", "plans", f"user-{uid}")
    os.makedirs(d, exist_ok=True)
    return d

def _save_plan(uid: int, start_date: _date, payload: dict) -> str:
    d = _plans_dir(uid)
    fp = os.path.join(d, f"{start_date.isoformat()}.json")
    with open(fp, "w", encoding="utf-8") as f:
        json.dump(payload, f, ensure_ascii=False, indent=2)
    return fp


@router.get("/plans")
def list_plans(
    user: User = Depends(get_current_user),
):
    out = []
    d = _plans_dir(user.id)
    try:
        for name in sorted(os.listdir(d)):
            if not name.endswith(".json"): 
                continue
            start = name[:-5]
            try:
                with open(os.path.join(d, name), "r", encoding="utf-8") as f:
                    data = json.load(f)
                win = data.get("window", {})
                rz = data.get("rationalization", {}) or {}
                days = data.get("days", []) or []
                out.append({
                    "start": win.get("start", start),
                    "end": win.get("end", start),
                    "diet_label": rz.get("diet_label"),
                    "meals_per_day": rz.get("meals_per_day"),
                    "count_days": len(days),
                    "created_at": data.get("created_at"),
                })
            except Exception:
                out.append({"start": start, "end": start})
    except FileNotFoundError:
        pass
    return out

@router.get("/plans/{start}")
def get_plan(
    start: str,
    user: User = Depends(get_current_user),
):
    fp = os.path.join(_plans_dir(user.id), f"{start}.json")
    if not os.path.exists(fp):
        raise HTTPException(status_code=404, detail="Plan not found")
    with open(fp, "r", encoding="utf-8") as f:
        data = json.load(f)
    return data


# ---------- Grocery pricing & store assignment ----------
def _normalize_item(name: str) -> str:
    n = (name or "").strip().lower()
    repl = {
        "chicken breast":"chicken breast","chicken thighs":"chicken thighs","romaine":"romaine","parmesan":"parmesan",
        "caesar dressing":"caesar dressing","salmon":"salmon","salmon fillets":"salmon",
        "asparagus":"asparagus","lemon":"lemon","ground turkey":"ground turkey","lettuce":"lettuce",
        "bell peppers":"bell pepper","bell pepper":"bell pepper","diced tomatoes":"diced tomatoes",
        "kidney beans":"kidney beans","chili seasoning":"chili seasoning","canned tuna":"tuna","tuna":"tuna",
        "green beans":"green beans","eggs":"eggs","olives":"olives","cod":"cod","cod fillets":"cod",
        "broccoli":"broccoli","olive oil":"olive oil","cucumber":"cucumber","tomatoes":"tomato","tomato":"tomato",
        "feta":"feta","marinara":"marinara","zucchini":"zucchini","beef strips":"beef","beef":"beef",
        "onions":"onion","onion":"onion","fajita seasoning":"fajita seasoning","shrimp":"shrimp",
        "steak":"steak","mixed greens":"mixed greens","cherry tomatoes":"cherry tomato","cabbage":"cabbage",
        "soy sauce":"soy sauce","garlic":"garlic","greek yogurt":"greek yogurt","walnuts":"walnuts",
        "berries":"berries","cauli rice":"cauli rice","cheddar":"cheddar","coleslaw mix":"coleslaw mix",
        "mayo":"mayo","mixed veg":"mixed veg","vinaigrette":"vinaigrette","unsweetened almond milk":"almond milk",
        "whey isolate":"whey isolate","spinach":"spinach","ground beef patty":"ground beef"
    }
    # try exact keys first, else collapse plurals
    for k,v in repl.items():
        if k in n: return v
    if n.endswith("s"): n = n[:-1]
    return n

# Simple local price catalog (USD per unit)
_PRICE_CATALOG = {
    "ALDI": {
        "eggs": 0.25, "romaine": 1.49, "parmesan": 4.50, "caesar dressing": 2.49, "chicken breast": 3.49,
        "salmon": 9.99, "asparagus": 2.49, "lemon": 0.69, "ground turkey": 3.29, "lettuce": 1.49,
        "bell pepper": 0.89, "diced tomatoes": 0.95, "kidney beans": 0.85, "chili seasoning": 0.49,
        "tuna": 0.89, "green beans": 1.29, "olives": 2.29, "cod": 6.99, "broccoli": 1.69, "olive oil": 5.99,
        "cucumber": 0.69, "tomato": 0.39, "feta": 2.49, "marinara": 1.79, "zucchini": 0.79, "beef": 5.49,
        "onion": 0.69, "fajita seasoning": 0.49, "shrimp": 6.99, "steak": 8.99, "mixed greens": 2.49,
        "cherry tomato": 2.29, "cabbage": 1.49, "soy sauce": 1.19, "garlic": 0.39, "greek yogurt": 0.89,
        "walnuts": 0.89, "berries": 2.49, "cauli rice": 2.49, "cheddar": 2.49, "coleslaw mix": 1.49,
        "mayo": 2.49, "mixed veg": 2.49, "vinaigrette": 2.49, "almond milk": 2.29, "whey isolate": 0.90, "spinach": 1.49,
        "chicken thighs": 2.29, "ground beef": 4.29
    },
    "WALMART": {
        "eggs": 0.28, "romaine": 1.98, "parmesan": 4.98, "caesar dressing": 2.98, "chicken breast": 3.29,
        "salmon": 10.49, "asparagus": 2.68, "lemon": 0.78, "ground turkey": 3.49, "lettuce": 1.78,
        "bell pepper": 0.98, "diced tomatoes": 1.08, "kidney beans": 0.92, "chili seasoning": 0.58,
        "tuna": 0.92, "green beans": 1.49, "olives": 2.68, "cod": 7.29, "broccoli": 1.89, "olive oil": 6.49,
        "cucumber": 0.78, "tomato": 0.48, "feta": 2.78, "marinara": 1.98, "zucchini": 0.88, "beef": 5.19,
        "onion": 0.78, "fajita seasoning": 0.58, "shrimp": 7.49, "steak": 9.49, "mixed greens": 2.78,
        "cherry tomato": 2.49, "cabbage": 1.68, "soy sauce": 1.29, "garlic": 0.48, "greek yogurt": 0.98,
        "walnuts": 0.98, "berries": 2.78, "cauli rice": 2.68, "cheddar": 2.68, "coleslaw mix": 1.78,
        "mayo": 2.98, "mixed veg": 2.68, "vinaigrette": 2.98, "almond milk": 2.49, "whey isolate": 1.10, "spinach": 1.78,
        "chicken thighs": 2.19, "ground beef": 4.09
    },
    "COSTCO": {
        "eggs": 0.22, "romaine": 1.39, "parmesan": 4.20, "caesar dressing": 2.39, "chicken breast": 3.19,
        "salmon": 9.49, "asparagus": 2.29, "lemon": 0.55, "ground turkey": 3.09, "lettuce": 1.29,
        "bell pepper": 0.85, "diced tomatoes": 0.89, "kidney beans": 0.79, "chili seasoning": 0.45,
        "tuna": 0.85, "green beans": 1.09, "olives": 2.09, "cod": 6.69, "broccoli": 1.49, "olive oil": 5.49,
        "cucumber": 0.59, "tomato": 0.35, "feta": 2.19, "marinara": 1.59, "zucchini": 0.69, "beef": 4.89,
        "onion": 0.59, "fajita seasoning": 0.39, "shrimp": 6.49, "steak": 8.49, "mixed greens": 2.19,
        "cherry tomato": 2.09, "cabbage": 1.29, "soy sauce": 1.09, "garlic": 0.29, "greek yogurt": 0.79,
        "walnuts": 0.79, "berries": 2.19, "cauli rice": 2.19, "cheddar": 2.19, "coleslaw mix": 1.29,
        "mayo": 2.19, "mixed veg": 2.19, "vinaigrette": 2.19, "almond milk": 2.09, "whey isolate": 0.80, "spinach": 1.29,
        "chicken thighs": 1.99, "ground beef": 3.89
    },
}

def _pick_store(item_name: str, prefer: Optional[str]) -> Tuple[str, Optional[float]]:
    norm = _normalize_item(item_name)
    candidates = []
    for store, table in _PRICE_CATALOG.items():
        price = table.get(norm)
        if price is not None:
            # slight preference boost for 'prefer' store
            adj = price * (0.98 if prefer and store == prefer.upper() else 1.0)
            candidates.append((store, price, adj))
    if not candidates:
        # default to preferred store if provided, else ALDI
        return (prefer.upper() if prefer else "ALDI", None)
    # choose by adjusted price (then real price)
    candidates.sort(key=lambda t: (t[2], t[1]))
    return (candidates[0][0], candidates[0][1])

class PriceAssignOut(BaseModel):
    items_priced: int
    store_totals: Dict[str, float]
    grand_total: float

@router.post("/groceries/price_assign")
def price_assign(
    prefer: Optional[str] = Query(None, description="Preferred store name like ALDI/WALMART/COSTCO; if absent, inferred from intake notes."),
    persist: bool = Query(True),
    user: User = Depends(get_current_user),
    session: Session = Depends(get_session),
):
    """
    Assign a store and prices to current (unpurchased) grocery_items for the user.
    Uses a local price catalog and infers preferred store from intake notes (e.g., 'shop at Aldi').
    Updates grocery_items.store, unit_price, total_price when persist=true.
    Returns totals by store and a grand total.
    """
    # Set RLS
    session.exec(text("SET app.user_id = :uid").bindparams(uid=user.id))
    try:
        # infer preferred store from intake
        if not prefer:
            intake = session.exec(
                select(Intake).where(Intake.user_id == user.id).order_by(Intake.id.desc()).limit(1)
            ).first()
            if intake:
                notes = ((intake.food_notes or "") + " " + (intake.goals or "")).lower()
                if "aldi" in notes: prefer = "ALDI"
                elif "walmart" in notes: prefer = "WALMART"
                elif "costco" in notes: prefer = "COSTCO"

        rows = session.exec(
            select(GroceryItem).where(GroceryItem.user_id == user.id).where((GroceryItem.purchased == False) | (GroceryItem.purchased == None)).order_by(GroceryItem.created_at.asc())
        ).all()
        store_totals = {}
        items_priced = 0

        for r in rows:
            store, unit = _pick_store(r.name, prefer)
            qty = float(r.quantity) if r.quantity is not None else 1.0
            total = (unit * qty) if unit is not None else None
            if persist:
                r.store = store
                r.unit_price = unit
                r.total_price = total
                session.add(r)
            if total is not None:
                store_totals[store] = store_totals.get(store, 0.0) + float(total)
                items_priced += 1

        if persist:
            session.commit()

        grand = sum(store_totals.values()) if store_totals else 0.0
        # Round to 2 decimals for output
        store_totals = {k: round(v, 2) for k,v in store_totals.items()}
        return {"items_priced": items_priced, "store_totals": store_totals, "grand_total": round(grand, 2)}
    finally:
        session.exec(text("RESET app.user_id"))



@router.get("/groceries/price_preview")
def price_preview(
    prefer: Optional[str] = Query(None, description="Preferred store like ALDI/WALMART/COSTCO; inferred from intake if omitted."),
    user: User = Depends(get_current_user),
    session: Session = Depends(get_session),
):
    """
    Compute a price+store plan for current unpurchased grocery items (no DB writes).
    Uses local price catalog + simple preference inference from intake notes/goals.
    """
    # RLS
    session.exec(text("SET app.user_id = :uid").bindparams(uid=user.id))
    try:
        # Prefer store inference
        if not prefer:
            intake = session.exec(
                select(Intake).where(Intake.user_id == user.id).order_by(Intake.id.desc()).limit(1)
            ).first()
            if intake:
                notes = ((getattr(intake,"food_notes","") or "") + " " + (getattr(intake,"goals","") or "")).lower()
                if "aldi" in notes: prefer = "ALDI"
                elif "walmart" in notes: prefer = "WALMART"
                elif "costco" in notes: prefer = "COSTCO"
        prefer = (prefer or "ALDI").upper()

        rows = session.exec(
            select(GroceryItem).where(GroceryItem.user_id == user.id).where((GroceryItem.purchased == False) | (GroceryItem.purchased == None)).order_by(GroceryItem.created_at.asc())
        ).all()

        # Use existing _pick_store helper if present; else fallback
        def _fallback_pick_store(name: str, prefer_store: Optional[str]):
            try:
                return _pick_store(name, prefer_store)
            except NameError:
                return ((prefer_store or "ALDI"), None)

        items=[]; store_totals={}
        for r in rows:
            store, unit = _fallback_pick_store(r.name, prefer)
            qty = float(r.quantity) if r.quantity is not None else 1.0
            total = (unit * qty) if unit is not None else None
            items.append({
                "id": r.id, "name": r.name, "quantity": r.quantity, "unit": r.unit,
                "store": store, "unit_price": unit, "total_price": (round(float(total),2) if total is not None else None)
            })
            if total is not None:
                store_totals[store] = store_totals.get(store, 0.0) + float(total)

        grand = sum(store_totals.values()) if store_totals else 0.0
        return {
            "items": items,
            "store_totals": {k: round(v,2) for k,v in store_totals.items()},
            "grand_total": round(grand, 2),
            "preferred_store": prefer
        }
    finally:
        session.exec(text("RESET app.user_id"))
