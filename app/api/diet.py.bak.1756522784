from sqlalchemy import text
from typing import List, Optional, Dict
from datetime import datetime
from pydantic import BaseModel, conint, confloat
from fastapi import APIRouter, Depends, HTTPException, Query
from sqlmodel import Session, select

from ..core.db import get_session
from ..core.security import get_current_user
from ..models import User, Meal, MealItem, GroceryItem, Intake

router = APIRouter()

# ---------- Meals ----------
class MealItemIn(BaseModel):
    name: str
    calories: Optional[conint(ge=0)] = None
    quantity: Optional[confloat(ge=0)] = None
    unit: Optional[str] = None

class MealCreate(BaseModel):
    name: str
    eaten_at: Optional[datetime] = None
    items: List[MealItemIn] = []

@router.post("/meals", status_code=201)
def create_meal(payload: MealCreate, user: User = Depends(get_current_user), session: Session = Depends(get_session)):
    meal = Meal(
        user_id=user.id,
        name=payload.name,
        eaten_at=payload.eaten_at or datetime.utcnow(),
        total_calories=(sum(i.calories or 0 for i in payload.items) if payload.items else None),
    )
    session.add(meal)
    session.commit()
    session.refresh(meal)

    for it in payload.items:
        mi = MealItem(meal_id=meal.id, name=it.name, calories=it.calories, quantity=it.quantity, unit=it.unit)
        session.add(mi)
    session.commit()

    return {"id": meal.id, "name": meal.name, "eaten_at": meal.eaten_at.isoformat(), "total_calories": meal.total_calories, "items": len(payload.items)}

@router.get("/meals")
def list_meals(
    user: User = Depends(get_current_user),
    session: Session = Depends(get_session),
    limit: int = Query(10, ge=1, le=100),
):
    meals = session.exec(
        select(Meal).where(Meal.user_id == user.id).order_by(Meal.eaten_at.desc()).limit(limit)
    ).all()
    if not meals:
        return []
    meal_ids = [m.id for m in meals]
    items = session.exec(select(MealItem).where(MealItem.meal_id.in_(meal_ids))).all()
    by_meal: Dict[int, List[MealItem]] = {}
    for it in items:
        by_meal.setdefault(it.meal_id, []).append(it)
    out = []
    for m in meals:
        out.append({
            "id": m.id,
            "name": m.name,
            "eaten_at": m.eaten_at.isoformat(),
            "total_calories": m.total_calories,
            "items": [{"name": it.name, "calories": it.calories, "qty": it.quantity, "unit": it.unit} for it in by_meal.get(m.id, [])]
        })
    return out

# ---------- Groceries ----------
class GroceryIn(BaseModel):
    name: str
    quantity: Optional[confloat(ge=0)] = None
    unit: Optional[str] = None

class GroceryUpdate(BaseModel):
    purchased: bool

@router.post("/groceries", status_code=201)
def add_grocery(payload: GroceryIn, user: User = Depends(get_current_user), session: Session = Depends(get_session)):
    g = GroceryItem(user_id=user.id, name=payload.name, quantity=payload.quantity, unit=payload.unit, purchased=False)
    session.add(g)
    session.commit()
    session.refresh(g)
    return {"id": g.id, "name": g.name, "quantity": g.quantity, "unit": g.unit, "purchased": g.purchased}

@router.get("/groceries")
def list_groceries(
    user: User = Depends(get_current_user),
    session: Session = Depends(get_session),
    only_open: bool = Query(True),
):
    q = select(GroceryItem).where(GroceryItem.user_id == user.id)
    if only_open:
        q = q.where(GroceryItem.purchased == False)  # noqa: E712
    rows = session.exec(q.order_by(GroceryItem.created_at.desc())).all()
    return [{"id": r.id, "name": r.name, "quantity": r.quantity, "unit": r.unit, "purchased": r.purchased, "created_at": r.created_at.isoformat()} for r in rows]

@router.patch("/groceries/{item_id}")
def update_grocery(item_id: int, payload: GroceryUpdate, user: User = Depends(get_current_user), session: Session = Depends(get_session)):
    g = session.get(GroceryItem, item_id)
    if not g or g.user_id != user.id:
        raise HTTPException(status_code=404, detail="Item not found")
    g.purchased = payload.purchased
    session.add(g)
    session.commit()
    session.refresh(g)
    return {"id": g.id, "name": g.name, "purchased": g.purchased}

# ---------- Intake (DB-backed with RLS) ----------
class IntakeIn(BaseModel):
    name: Optional[str] = None
    age: Optional[int] = None
    sex: Optional[str] = None
    height_in: Optional[int] = None
    weight_lb: Optional[int] = None
    diabetic: Optional[bool] = None
    conditions: Optional[str] = None
    meds: Optional[str] = None
    goals: Optional[str] = None
    zip: Optional[str] = None
    gym: Optional[str] = None

@router.get("/intake")
def get_intake(
    user: User = Depends(get_current_user),
    session: Session = Depends(get_session),
):
    # Set RLS context for this transaction
    session.exec(text("SET LOCAL app.user_id = :uid").bindparams(uid=user.id))
    row = session.exec(
        select(Intake).where(Intake.user_id == user.id).order_by(Intake.id.desc()).limit(1)
    ).first()
    if not row:
        return None
    return {
        "id": row.id,
        "user_id": row.user_id,
        "name": row.name,
        "age": row.age,
        "sex": row.sex,
        "height_in": row.height_in,
        "weight_lb": row.weight_lb,
        "diabetic": row.diabetic,
        "conditions": row.conditions,
        "meds": row.meds,
        "goals": row.goals,
        "zip": row.zip,
        "gym": row.gym,
        "created_at": row.created_at.isoformat() if row.created_at else None,
        "updated_at": row.updated_at.isoformat() if row.updated_at else None,
    }

@router.post("/intake", status_code=201)
def upsert_intake(
    payload: IntakeIn,
    user: User = Depends(get_current_user),
    session: Session = Depends(get_session),
):
    # Set RLS context for this transaction
    session.exec(text("SET LOCAL app.user_id = :uid").bindparams(uid=user.id))

    # Try to fetch existing intake for this user (latest)
    existing = session.exec(
        select(Intake).where(Intake.user_id == user.id).order_by(Intake.id.desc()).limit(1)
    ).first()

    now_fields = {k: v for k, v in payload.dict().items() if v is not None}

    if existing:
        # Update existing
        for k, v in now_fields.items():
            setattr(existing, k, v)
        # Always touch updated_at
        from datetime import datetime as _dt
        existing.updated_at = _dt.utcnow()
        session.add(existing)
        session.commit()
        session.refresh(existing)
        row = existing
    else:
        # Create new
        from datetime import datetime as _dt
        row = Intake(user_id=user.id, **now_fields)
        # SQLModel defaults set created_at/updated_at; ensure updated_at touches now
        row.updated_at = _dt.utcnow()
        session.add(row)
        session.commit()
        session.refresh(row)

    return {
        "id": row.id,
        "user_id": row.user_id,
        "name": row.name,
        "age": row.age,
        "sex": row.sex,
        "height_in": row.height_in,
        "weight_lb": row.weight_lb,
        "diabetic": row.diabetic,
        "conditions": row.conditions,
        "meds": row.meds,
        "goals": row.goals,
        "zip": row.zip,
        "gym": row.gym,
        "created_at": row.created_at.isoformat() if row.created_at else None,
        "updated_at": row.updated_at.isoformat() if row.updated_at else None,
    }
